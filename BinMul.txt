; ******************************************************************************************** //
;/* 该机器码和微指令用于实现八位（1 + 7）带符号位的二进制乘法                                           //
;* 操作步骤：                                                                                                                          //
;*1、 在IN单元输入第一个数送入R0单元                                                                                  //
;*2、在IN单元输入第二个数到R1单元                                                                                      //
;*3、点击CMA界面的连续运行按钮，就会在数码管单元分次显示高八位和低八位结果                //                                                                //
; *******************************************************************************************//

$P 00 20  ;IN R0, 00H  ;输入被乘数第一个数到R0寄存器
$P 01 00  ;
$P 02 21  ;IN R1, 00H  ;输入乘数第二个数到R1寄存器
$P 03 00  ;
$P 04 62;LDI R2 80H   R2 = 10000000 用于取符号位 
$P 05 80
$P 06 63;LDI R3 80H    与上同理
$P 07 80
$P 08 12;AND R2, R0   进行与运算求取第一个数的最高位，即符号位
$P 09 17;AND R3, R1   同上
$P 0A 0E;ADD R2, R3   相加代替异或
$P 0B D2;STA 00 F5H, R2 把符号位的结果存储到F5单元
$P 0C F5
$P 0D 62;LDI R2, 7FH R2 = 01111111 用于取绝对值
$P 0E 7F;
$P 0F 63;LDI R3, 7FH 同上
$P 10 7F;
$P 11 18;AND R0, R2   进行与运算取绝对值
$P 12 1D;AND R1, R3   同上

$P 13 62  ;LDI R2, 00H  用R2来存储循环次数
$P 14 00  ;
$P 15 63  ;LDI R3, 00H  用R3来存储部分积
$P 16 00  ;  
$P 17 D0  ;STA 00, F0H, R0     寄存器有限，将被乘数绝对值存储在F0单元中   
$P 18 F0  ;
$P 19 60  ;LDI R0, 00H        初始化进位标志位为0 
$P 1A 00  ;
$P 1B D0  ;STA 00H, F4H, R0    将进位标志存储在内存F4单元
$P 1C F4  ;

; 主方法
$P 1D 72 ;INC R2              进行循环比较前就先进行计数加一操作，7位乘法进行8次
$P 1E 60 ;LDI R0, 09H         R0赋值为需要循环的次数+1
$P 1F 09 ;
$P 20 88 ;SUB R0, R2      比较循环次数
$P 21 F0 ; BZC Output      计算完毕跳转输出    
$P 22 5B ;
$P 23 60   ;LDI R0,01H    
$P 24 01
$P 25 14   ;AND RO,R1	R1和01H AND，获得乘数的最低位
$P 26 F0   ;BZC noAdd  乘数最低位是0，部分积和乘数只需右移 跳转地址2A
$P 27 2A
$P 28 E0   ;JMP add    乘数最低位是1，部分积需要加被乘数，然后部分积和乘数右移 地址49
$P 29 49

; 乘数最低为此时为0 跳转至此
;noAdd  
$P 2A 60   ;LDI R0,01H;    
$P 2B 01
$P 2C D2   ;STA 00H, F1H, R2   将循环次数存入内存F1单元
$P 2D F1
$P 2E A1   ;RR R1,R0  对y进行一位右环移
$P 2F A3   ;RR R3,R0  对部分积进行右环移
$P 30 62   ;LDI R2, 80H  
$P 31 80
$P 32 1E   ;AND R2,R3   将部分积和80H AND操作，取出部分积的最高位 （部分积的最低位是要放入乘数的最高位）
$P 33 F0   ;BZC set0    部分积最高位为0，需要把乘数最高位设置为0 地址为37
$P 34 37
$P 35 E0   ;JMP set1    部分积最高位为1， 需要把乘数最高位设置为1 地址为40
$P 36 40

;set0 部分积最高位为0执行将乘数最高位置0
$P 37 66   ;LDI R2, 7FH
$P 38 7F
$P 39 19   ;AND R1,R2	R1与7FH AND 将乘数最高位置0
$P 3A E0   ;JMP  FC   跳转到FC子程序 判断进位	
$P 3B 6E   ;

;BACK 部分积最高位置完 回到Main程序
$P 3C C2    ;LAD 00H, F1H, R2	;取出计数值   
$P 3D F1
$P 3E E0     ;JMP Main
$P 3F 1D


;set1 部分积最高位为1执行将乘数最高位置1
$P 40 62    ;LDI R2, 80H
$P 41 80
$P 42 99    ;OR R1,R2	R1与80H OR 将乘数最高位置1
$P 43 E0    ;JMP  B0 判断进位标志子程序                  
$P 44 83   ;

;BACK1部分积最高位置完,跳回Main程序
$P 45 C2    ;LAD 00H, F1H, R2    ; 取出计数值
$P 46 F1
$P 47 E0    ;JMP Main
$P 48 1D

;add1
$P 49 C0    ;LAD 00, F0H, R0	;从存储器中取出被乘数  
$P 4A F0
$P 4B 03    ;ADD R3,R0	 ;加被乘数
$P 4C F0    ;BZC 相加有进位C0  
$P 4D 67    ;      

;相加无进位直接到此处，或相加有进位设置进位标志位1后跳转此处
;C1
$P 4E D2    ;STA 00H, F1H, R2	 ;存储计数值
$P 4F F1    
$P 50 62    ;LDI R2, 80H
$P 51 80
$P 52 60    ;LDI R0,01H 
$P 53 01
$P 54 A1    ;RR R1,R0       乘数右移一位     
$P 55 A3    ;RR R3,R0        部分积右移一位     
$P 56 1E    ;AND R2,R3	取部分积最高位
$P 57 F0    ;BZC set0              部分积最高位为0跳转
$P 58 37
$P 59 E0    ;JMP set1	部分积最高位为1跳转
$P 5A 40

;Output:
$P 5B C0    ;LAD 00, F5H, R0
$P 5C F5
$P 5D 03      ;ADD R1,R0 
$P 5E E0    ;JMP 98        输出结果的最高位6遍，才会显示一下
$P 5F 98;
$P 60 34    ;OUT 40H, R1
$P 61 40    
$P 62 D3    ;STA 00H, F2H, R3
$P 63 F2
$P 64 D1    ;STA 00H, F3H, R1
$P 65 F3
$P 66 50    ;HALT

;相加有进位，置标志位为1:
;C0
$P 67 60      ;LDI R0 01H
$P 68 01      ;
$P 69 D0      ;STA 00H, F4H, R0	 ;存储进位标志
$P 6A F4
$P 6B 80      ;SUB R0,R0     ;清空R0
$P 6C E0      ;JMP   C1  ;相加有进位返回此处
$P 6D 4E


;判断进位标志位，判断是否置部分积最高位0  
;FC:
$P 6E C0   ;LAD 00H, F4H, R0  ;取出进位标志位
$P 6F F4   ;
$P 70 62   ;LDI R2,01H
$P 71 01   ;
$P 72 82   ;SUB R2,R0   看标志位是否为1，如果是，跳到CROSS子程序
$P 73 F0   ;BZC CROSS
$P 74 7A   ;
$P 75 62   ;LDI R2, 7FH
$P 76 7F   ;
$P 77 1B   ;AND R3,R2    ;7FH与R3 AND 将部分积最高位置0
$P 78 E0   ;JMP BACK
$P 79 3C   ;


;CROSS:    进位标志为1，将部分积最高位置1
$P 7A 62   ;LDI R2, 80H
$P 7B 80   ;
$P 7C 9B   ;OR R3, R2   ;部分积最高位置1
$P 7D 60   ;LDI R0, 00H        ;重置标志位为0/
$P 7E 00   ;
$P 7F D0   ;STA 00H, F4H, R0	存储标志位
$P 80 F4   ;
$P 81 E0   ;JMP BACK
$P 82 3C   ;

;判断进位标志位，置部分积最高位0  
;FC1
$P 83 C0   ;LAD 00H, F4H, R0  ;取出进位标志位
$P 84 F4   ;
$P 85 62   ;LDI R2,01H
$P 86 01   ;
$P 87 82   ;SUB R2,R0 判断标志位
$P 88 F0   ;BZC B2	标志位为1跳转
$P 89 8F   ;
$P 8A 62   ;LDI R2, 7FH
$P 8B 7F   ;
$P 8C 1B   ;AND R3,R2    ;标志位为0 部分积最高位 置0
$P 8D E0   ;JMP B1
$P 8E 45   ;

;CROSS1: 进位标志为1 部分积最高位 置1
$P 8F 62   ;LDI R2, 80H
$P 90 80   ;
$P 91 9B   ;OR R3, R2   ;部分积最高位 置1
$P 92 60   ;LDI R0, 00H        ;重置标志位为0 
$P 93 00   ;
$P 94 D0   ;STA 00H, F4H, R0
$P 95 F4   ;
$P 96 E1   ;JMP BACK1
$P 97 45   ;

$P 98 3C ;OUT 40H,R3
$P 99 40
$P 9A 3C
$P 9B 40
$P 9C 3C
$P 9D 40
$P 9E 3C
$P 9F 40
$P A0 3C
$P A1 40
$P A2 3C
$P A3 40
$P A4 3C
$P A5 40
$P A6 3C
$P A7 40
$P A8 3C
$P A9 40
$P AA E0
$P AB 60

$M 00 000001 ; NOP
$M 01 006D43 ; PC->AR, PC 加1
$M 03 107070 ; MEM->IR, P<1>
$M 04 002405 ; RS->B
$M 05 04B201 ; A 加B->RD
$M 06 002407 ; RS->B
$M 07 013201 ; A 与B->RD
$M 08 106009 ; MEM->AR
$M 09 183001 ; IO->RD
$M 0A 106010 ; MEM->AR
$M 0B 000001 ; NOP
$M 0C 103001 ; MEM->RD
$M 0D 200601 ; RD->MEM
$M 0E 005341 ; A->PC
$M 0F 0000CB ; NOP, P<3>
$M 10 280401 ; RS->IO
$M 11 103001 ; MEM->RD
$M 12 06B201 ; A 加1->RD
$M 13 002414 ; RS->B
$M 14 05B201 ; A 减B->RD
$M 15 002416 ; RS->B
$M 16 01B201 ; A 或B->RD
$M 17 002418 ; RS->B
$M 18 02B201 ; A 右环移->RD
$M 1B 005341 ; A->PC
$M 1C 10101D ; MEM->A
$M 1D 10608C ; MEM->AR, P<2>
$M 1E 10601F ; MEM->AR
$M 1F 101020 ; MEM->A
$M 20 10608C ; MEM->AR, P<2>
$M 28 101029 ; MEM->A
$M 29 00282A ; RI->B
$M 2A 04E22B ; A 加B->AR
$M 2B 04928C ; A 加B->A, P<2>
$M 2C 10102D ; MEM->A
$M 2D 002C2E ; PC->B
$M 2E 04E22F ; A 加B->AR
$M 2F 04928C ; A 加B->A, P<2>
$M 30 001604 ; RD->A
$M 31 001606 ; RD->A
$M 32 006D48 ; PC->AR, PC 加1
$M 33 006D4A ; PC->AR, PC 加1
$M 34 003401 ; RS->RD
$M 35 000035 ; NOP
$M 36 006D51 ; PC->AR, PC 加1
$M 37 001612 ; RD->A
$M 38 001613 ; RD->A
$M 39 001615 ; RD->A
$M 3A 001617 ; RD->A
$M 3B 000001 ; NOP
$M 3C 006D5C ; PC->AR, PC 加1
$M 3D 006D5E ; PC->AR, PC 加1
$M 3E 006D68 ; PC->AR, PC 加1
$M 3F 006D6C ; PC->AR, PC 加1


